# Libraries

```{r}
library(goalmodel)
```

# Data

```{r}
epl_19_20 = read.csv('https://www.football-data.co.uk/mmz4281/1920/E0.csv')
epl_20_21 = read.csv('https://www.football-data.co.uk/mmz4281/2021/E0.csv')
epl_21_22 = read.csv('https://www.football-data.co.uk/mmz4281/2122/E0.csv')
epl_22_23 = read.csv('https://www.football-data.co.uk/mmz4281/2223/E0.csv')

features = c('Date', 'HomeTeam', 'AwayTeam', 'FTHG', 'FTAG',
             'AvgCH', 'AvgCD', 'AvgCA', 'AvgC.2.5', 'AvgC.2.5.1')

epl_19_20 = epl_19_20[, features]
epl_20_21 = epl_20_21[, features]
epl_21_22 = epl_21_22[, features]
epl_22_23 = epl_22_23[, features]
```

# Some Functions

```{r}
ou_odds_to_prob = function(ou_odds, normalize=TRUE){
  
  stopifnot(all(ou_odds >= 1, na.rm=TRUE))
  
  if (!is.matrix(ou_odds)){
    
    if ('data.frame' %in% class(ou_odds)){
      ou_odds = as.matrix(ou_odds)
    } else {
      ou_odds = matrix(ou_odds, nrow=1,
                    dimnames = list(NULL, names(ou_odds)))
    }
  }
  
  # Prepare the list that will be returned.
  out = vector(mode='list', length=2)
  names(out) = c('probabilities', 'margin')
  
  # Some useful quantities
  n_odds = nrow(ou_odds)
  n_outcomes = ncol(ou_odds)
  
  # Inverted odds and margins
  inverted_odds = 1 / ou_odds
  inverted_odds_sum = rowSums(inverted_odds)
  out$margin = inverted_odds_sum - 1

  out$probabilities = inverted_odds / inverted_odds_sum
    
  ## do a final normalization to make sure the probabilities sum to 1 without rounding errors.
  if (normalize){
    out$probabilities = (1 * out$probabilities) / rowSums(out$probabilities)
  }
  
  return(out)
}
```

```{r}
odds_to_prob = function(odds, normalize=TRUE){
  
  stopifnot(all(odds >= 1, na.rm=TRUE))
  
  if (!is.matrix(odds)){
    
    if ('data.frame' %in% class(odds)){
      odds = as.matrix(odds)
    } else {
      odds = matrix(odds, nrow=1,
                    dimnames = list(NULL, names(odds)))
    }
  }
  
  # Prepare the list that will be returned.
  out = vector(mode='list', length=2)
  names(out) = c('probabilities', 'margin')
  
  # Some useful quantities
  n_odds = nrow(odds)
  n_outcomes = ncol(odds)
  
  # Inverted odds and margins
  inverted_odds = 1 / odds
  inverted_odds_sum = rowSums(inverted_odds)
  out$margin = inverted_odds_sum - 1

  out$probabilities = inverted_odds / inverted_odds_sum
    
  ## do a final normalization to make sure the probabilities sum to 1 without rounding errors.
  if (normalize){
    out$probabilities = (1 * out$probabilities) / rowSums(out$probabilities)
  }
  
  # Make sure the matrix of implied probabilities has column names.
  if (!is.null(colnames(odds))){
    colnames(out$probabilities) = colnames(odds)
  }
  
  # check if there are any probabilities outside the 0-1 range.
  problematic = apply(out$probabilities, MARGIN = 1, FUN=function(x){any(x > 1 | x < 0)})
  problematic[is.na(problematic)] = TRUE
  
  if (any(problematic, na.rm=TRUE)){
    warning(sprintf('Probabilities outside the 0-1 range produced at %d instances.\n',
                    sum(problematic)))
  }
  
  out$problematic = problematic
  
  return(out)
}
```

```{r}
mis_prob_sq_error = function(pars, trgt_probs){
  
  pars = exp(pars) # trick to avoid negative lambda parameters.
  hda_ou_probs = numeric(5)
  probmat = stats::dpois(0:49, lambda=pars[1]) %o% stats::dpois(0:49, lambda=pars[2])
  
  #1x2
  hda_ou_probs[2] = sum(diag(probmat))
  hda_ou_probs[1] = sum(probmat[lower.tri(probmat)])
  hda_ou_probs[3] = 1 - sum(hda_ou_probs[1:2])
  
  #ou
  total_goals = matrix(NA, nrow = 50, ncol = 50)
  
  for (i in 1:50){
    for (j in 1:50){
      total_goals[i, j] = (i-1) + (j-1)
    }
  }
  
  hda_ou_probs[4] = sum(probmat[total_goals > 2.5])
  hda_ou_probs[5] = sum(probmat[total_goals < 2.5])
  
  sum((hda_ou_probs - trgt_probs)^2)
  
}
```

```{r}
mis_prob_to_expg = function(probabilities){
  
  # Convert to matrix
  if (!is.matrix(probabilities)){
    if (is.numeric(probabilities)){
      probabilities = matrix(probabilities, nrow=1,
                              dimnames = list(NULL, names(probabilities)))
    } else {
      probabilities = as.matrix(probabilities)
    }
    
    
  }
  
  stopifnot(ncol(probabilities) == 5,
            all(abs(rowSums(probabilities) - 1 - 1) < 0.0001))
  
  expg = matrix(ncol=2, nrow=nrow(probabilities))
  sq_errors = numeric(nrow(probabilities))
  
  for (i in 1:nrow(probabilities)){
    
    optim_res = stats::optim(c(0,0), fn=mis_prob_sq_error,
                              trgt_prob=probabilities[i,])
    
    expg[i,] = exp(optim_res$par)
    sq_errors[i] = optim_res$value
    
  }
  
  out = list(expg = expg, sq_errors=sq_errors)
  
  return(out)
}
```

# Some preparations

```{r}
## last season
last_season = sub_21_22

## hda and ou
last_season_hda_prob = odds_to_prob(last_season[, c('AvgCH', 'AvgCD', 'AvgCA')])$probabilities
last_season_ou_prob = ou_odds_to_prob(last_season[, c('AvgC.2.5', 'AvgC.2.5.1')])$probabilities

last_season_hdaou_prob = cbind(last_season_hda_prob, last_season_ou_prob)
last_season_hdaou_expg = mis_prob_to_expg(last_season_hdaou_prob)

last_season$hdaou_xhg = last_season_hdaou_expg$expg[, 1]
last_season$hdaou_xag = last_season_hdaou_expg$expg[, 2]

## hda
last_season_hda_expg = prob_to_expg(last_season_hda_prob)

last_season$hda_xhg = last_season_hda_expg$expg[, 1]
last_season$hda_xag = last_season_hda_expg$expg[, 2]

## current season
current_season = sub_22_23

## hda and ou
current_season_hda_prob = odds_to_prob(current_season[, c('AvgCH', 'AvgCD', 'AvgCA')])$probabilities
current_season_ou_prob = ou_odds_to_prob(current_season[, c('AvgC.2.5', 'AvgC.2.5.1')])$probabilities

current_season_hdaou_prob = cbind(current_season_hda_prob, current_season_ou_prob)
current_season_hdaou_expg = mis_prob_to_expg(current_season_hdaou_prob)

current_season$hdaou_xhg = current_season_hdaou_expg$expg[, 1]
current_season$hdaou_xag = current_season_hdaou_expg$expg[, 2]

## hda
current_season_hda_expg = prob_to_expg(current_season_hda_prob)

current_season$hda_xhg = current_season_hda_expg$expg[, 1]
current_season$hda_xag = current_season_hda_expg$expg[, 2]
```

```{r}
current_season_teams = unique(current_season$HomeTeam)
last_season_teams = unique(last_season$HomeTeam)

new_teams = current_season_teams[!(current_season_teams %in% last_season_teams)]
dropped_teams = last_season_teams[!(last_season_teams %in% current_season_teams)] 
```

```{r}
replaced_last_season = last_season

for (i in 1:length(new_teams)){
  
  replaced_last_season$HomeTeam[replaced_last_season$HomeTeam == dropped_teams[i]] = new_teams[i]
  replaced_last_season$AwayTeam[replaced_last_season$AwayTeam == dropped_teams[i]] = new_teams[i]
  
}

replaced_last_season_teams = unique(replaced_last_season$HomeTeam)
```

# Modelling

## The first 50s

```{r}
first_preds = current_season[1:50, ]

first_preds$hda_expg1 = rep(NA, 50)
first_preds$hda_expg2 = rep(NA, 50)

first_preds$hdaou_expg1 = rep(NA, 50)
first_preds$hdaou_expg2 = rep(NA, 50)

new_train_set = replaced_last_season

## HDA
for (i in 1:5){
  
  #i = 1
  replaced_model = goalmodel(goals1 = round(new_train_set$hda_xhg), goals2 = round(new_train_set$hda_xag),
                             team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam,
                             model = 'gaussian')
  lower_bound = 1 + (i-1)*10
  upper_bound = i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred = predict_expg(replaced_model, return_df = T,
                      team1 = current_season$HomeTeam[lower_bound:upper_bound], 
                      team2 = current_season$AwayTeam[lower_bound:upper_bound])
  
  first_preds$hda_expg1[lower_bound:upper_bound] = pred$expg1
  first_preds$hda_expg2[lower_bound:upper_bound] = pred$expg2
  
  new_train_set = rbind(new_train_set, new_match_day) 
  
}

## HDA + OU
for (i in 1:5){
  
  #i = 1
  replaced_model = goalmodel(goals1 = round(new_train_set$hdaou_xhg), goals2 = round(new_train_set$hdaou_xag),
                             team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam,
                             model = 'gaussian')
  lower_bound = 1 + (i-1)*10
  upper_bound = i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred = predict_expg(replaced_model, return_df = T,
                      team1 = current_season$HomeTeam[lower_bound:upper_bound], 
                      team2 = current_season$AwayTeam[lower_bound:upper_bound])
  
  first_preds$hdaou_expg1[lower_bound:upper_bound] = pred$expg1
  first_preds$hdaou_expg2[lower_bound:upper_bound] = pred$expg2
  
  new_train_set = rbind(new_train_set, new_match_day) 
  
}
```

## The rest

```{r}
pred = current_season

pred$hda_expg1 = rep(NA, 380)
pred$hda_expg2 = rep(NA, 380)

pred$hdaou_expg1 = rep(NA, 380)
pred$hdaou_expg2 = rep(NA, 380)

played_matches = 50
new_train_set = current_season[1:played_matches, ]

## HDA
for (i in 1:33){
  
  model_xg = goalmodel(goals1 = round(new_train_set$hda_xhg), goals2 = round(new_train_set$hda_xag),
                       team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam, model = 'gaussian')
  
  lower_bound = played_matches + 1 + (i-1)*10
  upper_bound = played_matches + i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred_xg = predict_expg(model_xg, return_df = T,
                         team1 = new_match_day$HomeTeam, 
                         team2 = new_match_day$AwayTeam)
  
  pred$hda_expg1[lower_bound:upper_bound] = pred_xg$expg1
  pred$hda_expg2[lower_bound:upper_bound] = pred_xg$expg2
  
  new_train_set = rbind(new_train_set, new_match_day)
  
}

## HDA and OU
for (i in 1:33){
  
  model_xg = goalmodel(goals1 = new_train_set$hdaou_xhg, goals2 = new_train_set$hdaou_xag,
                        team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam, model = 'gaussian')
  
  lower_bound = played_matches + 1 + (i-1)*10
  upper_bound = played_matches + i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred_xg = predict_expg(model_xg, return_df = T,
                      team1 = new_match_day$HomeTeam, 
                      team2 = new_match_day$AwayTeam)
  
  pred$hdaou_expg1[lower_bound:upper_bound] = pred_xg$expg1
  pred$hdaou_expg2[lower_bound:upper_bound] = pred_xg$expg2
  
  new_train_set = rbind(new_train_set, new_match_day)
  
}
```

# Draft

```{r}
fbref_data = fb_match_results(country = '', gender = 'M', season_end_year = '2023',
                              non_dom_league_url = 'https://fbref.com/en/comps/9/history/Premier-League-Seasons')
names(fbref_data)[names(fbref_data) == 'Home'] = 'HomeTeam'
names(fbref_data)[names(fbref_data) == 'Away'] = 'AwayTeam'
fbref_data = fbref_data[, c('Date', 'HomeTeam', 'AwayTeam', 'HomeGoals', 'AwayGoals', 'Home_xG', 'Away_xG')]
row.names(fbref_data) = c(1:380)
fbref_data = fbref_data[order(as.Date(fbref_data$Date, format = "%d/%m/%Y")), ]
fbref_data
```
I have an idea (sort of) and a question for you.

I'm not sure if the goalmodel is truely better than the ones in the paper because I've only tried one of the ideas.

This is my way: I got the parameters r and p from this formula: https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_parameterizations then generate samples using rnbinom(n, size, prob, mu) where size and prob are r and p respectively. And in my case with the five-bif_league data set, home and away corner kicks have the same parameter p (prob) but different mu (mean) and p (size or dispersion). I'm not sure if I need to pay attention to this? I read that if two independent NB variables X∼NB(r,p) and Y∼NB(s,p) then X+Y∼NB(r+s,p), right? 

I don't understand the correlation on residuals. Do you mean we need a model, make predictions, get residuals then calculate the correlation? Why should I do it on the residuals instead of the data itself?

I noticed you have a folder for Bivariate Poisson but apparently you haven't finished. I've heard of that but I have never actually worked with it and I think I should.

Thank you for another paper. I had a quick look at it and I think it's to be honest. But I'll still try if I can derive something from it.

Thank you and Merry Christmas.





