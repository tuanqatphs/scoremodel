# Libraries

```{r}
library(goalmodel)
```

# Data

```{r}
epl_19_20 = read.csv('https://www.football-data.co.uk/mmz4281/1920/E0.csv')
epl_20_21 = read.csv('https://www.football-data.co.uk/mmz4281/2021/E0.csv')
epl_21_22 = read.csv('https://www.football-data.co.uk/mmz4281/2122/E0.csv')
epl_22_23 = read.csv('https://www.football-data.co.uk/mmz4281/2223/E0.csv')

features = c('Date', 'HomeTeam', 'AwayTeam', 'FTHG', 'FTAG',
             'AvgCH', 'AvgCD', 'AvgCA', 'AvgC.2.5', 'AvgC.2.5.1')

epl_19_20 = epl_19_20[, features]
epl_20_21 = epl_20_21[, features]
epl_21_22 = epl_21_22[, features]
epl_22_23 = epl_22_23[, features]
```

# Some Functions

```{r}
ou_odds_to_prob = function(ou_odds, normalize=TRUE){
  
  stopifnot(all(ou_odds >= 1, na.rm=TRUE))
  
  if (!is.matrix(ou_odds)){
    
    if ('data.frame' %in% class(ou_odds)){
      ou_odds = as.matrix(ou_odds)
    } else {
      ou_odds = matrix(ou_odds, nrow=1,
                    dimnames = list(NULL, names(ou_odds)))
    }
  }
  
  # Prepare the list that will be returned.
  out = vector(mode='list', length=2)
  names(out) = c('probabilities', 'margin')
  
  # Some useful quantities
  n_odds = nrow(ou_odds)
  n_outcomes = ncol(ou_odds)
  
  # Inverted odds and margins
  inverted_odds = 1 / ou_odds
  inverted_odds_sum = rowSums(inverted_odds)
  out$margin = inverted_odds_sum - 1

  out$probabilities = inverted_odds / inverted_odds_sum
    
  ## do a final normalization to make sure the probabilities sum to 1 without rounding errors.
  if (normalize){
    out$probabilities = (1 * out$probabilities) / rowSums(out$probabilities)
  }
  
  return(out)
}
```

```{r}
odds_to_prob = function(odds, normalize=TRUE){
  
  stopifnot(all(odds >= 1, na.rm=TRUE))
  
  if (!is.matrix(odds)){
    
    if ('data.frame' %in% class(odds)){
      odds = as.matrix(odds)
    } else {
      odds = matrix(odds, nrow=1,
                    dimnames = list(NULL, names(odds)))
    }
  }
  
  # Prepare the list that will be returned.
  out = vector(mode='list', length=2)
  names(out) = c('probabilities', 'margin')
  
  # Some useful quantities
  n_odds = nrow(odds)
  n_outcomes = ncol(odds)
  
  # Inverted odds and margins
  inverted_odds = 1 / odds
  inverted_odds_sum = rowSums(inverted_odds)
  out$margin = inverted_odds_sum - 1

  out$probabilities = inverted_odds / inverted_odds_sum
    
  ## do a final normalization to make sure the probabilities sum to 1 without rounding errors.
  if (normalize){
    out$probabilities = (1 * out$probabilities) / rowSums(out$probabilities)
  }
  
  # Make sure the matrix of implied probabilities has column names.
  if (!is.null(colnames(odds))){
    colnames(out$probabilities) = colnames(odds)
  }
  
  # check if there are any probabilities outside the 0-1 range.
  problematic = apply(out$probabilities, MARGIN = 1, FUN=function(x){any(x > 1 | x < 0)})
  problematic[is.na(problematic)] = TRUE
  
  if (any(problematic, na.rm=TRUE)){
    warning(sprintf('Probabilities outside the 0-1 range produced at %d instances.\n',
                    sum(problematic)))
  }
  
  out$problematic = problematic
  
  return(out)
}
```

```{r}
mis_prob_sq_error = function(pars, trgt_probs){
  
  pars = exp(pars) # trick to avoid negative lambda parameters.
  hda_ou_probs = numeric(5)
  probmat = stats::dpois(0:49, lambda=pars[1]) %o% stats::dpois(0:49, lambda=pars[2])
  
  #1x2
  hda_ou_probs[2] = sum(diag(probmat))
  hda_ou_probs[1] = sum(probmat[lower.tri(probmat)])
  hda_ou_probs[3] = 1 - sum(hda_ou_probs[1:2])
  
  #ou
  total_goals = matrix(NA, nrow = 50, ncol = 50)
  
  for (i in 1:50){
    for (j in 1:50){
      total_goals[i, j] = (i-1) + (j-1)
    }
  }
  
  hda_ou_probs[4] = sum(probmat[total_goals > 2.5])
  hda_ou_probs[5] = sum(probmat[total_goals < 2.5])
  
  sum((hda_ou_probs - trgt_probs)^2)
  
}
```

```{r}
mis_prob_to_expg = function(probabilities){
  
  # Convert to matrix
  if (!is.matrix(probabilities)){
    if (is.numeric(probabilities)){
      probabilities = matrix(probabilities, nrow=1,
                              dimnames = list(NULL, names(probabilities)))
    } else {
      probabilities = as.matrix(probabilities)
    }
    
    
  }
  
  stopifnot(ncol(probabilities) == 5,
            all(abs(rowSums(probabilities) - 1 - 1) < 0.0001))
  
  expg = matrix(ncol=2, nrow=nrow(probabilities))
  sq_errors = numeric(nrow(probabilities))
  
  for (i in 1:nrow(probabilities)){
    
    optim_res = stats::optim(c(0,0), fn=mis_prob_sq_error,
                              trgt_prob=probabilities[i,])
    
    expg[i,] = exp(optim_res$par)
    sq_errors[i] = optim_res$value
    
  }
  
  out = list(expg = expg, sq_errors=sq_errors)
  
  return(out)
}
```

# Some preparations

```{r}
## last season
last_season = sub_21_22

## hda and ou
last_season_hda_prob = odds_to_prob(last_season[, c('AvgCH', 'AvgCD', 'AvgCA')])$probabilities
last_season_ou_prob = ou_odds_to_prob(last_season[, c('AvgC.2.5', 'AvgC.2.5.1')])$probabilities

last_season_hdaou_prob = cbind(last_season_hda_prob, last_season_ou_prob)
last_season_hdaou_expg = mis_prob_to_expg(last_season_hdaou_prob)

last_season$hdaou_xhg = last_season_hdaou_expg$expg[, 1]
last_season$hdaou_xag = last_season_hdaou_expg$expg[, 2]

## hda
last_season_hda_expg = prob_to_expg(last_season_hda_prob)

last_season$hda_xhg = last_season_hda_expg$expg[, 1]
last_season$hda_xag = last_season_hda_expg$expg[, 2]

## current season
current_season = sub_22_23

## hda and ou
current_season_hda_prob = odds_to_prob(current_season[, c('AvgCH', 'AvgCD', 'AvgCA')])$probabilities
current_season_ou_prob = ou_odds_to_prob(current_season[, c('AvgC.2.5', 'AvgC.2.5.1')])$probabilities

current_season_hdaou_prob = cbind(current_season_hda_prob, current_season_ou_prob)
current_season_hdaou_expg = mis_prob_to_expg(current_season_hdaou_prob)

current_season$hdaou_xhg = current_season_hdaou_expg$expg[, 1]
current_season$hdaou_xag = current_season_hdaou_expg$expg[, 2]

## hda
current_season_hda_expg = prob_to_expg(current_season_hda_prob)

current_season$hda_xhg = current_season_hda_expg$expg[, 1]
current_season$hda_xag = current_season_hda_expg$expg[, 2]
```

```{r}
current_season_teams = unique(current_season$HomeTeam)
last_season_teams = unique(last_season$HomeTeam)

new_teams = current_season_teams[!(current_season_teams %in% last_season_teams)]
dropped_teams = last_season_teams[!(last_season_teams %in% current_season_teams)] 
```

```{r}
replaced_last_season = last_season

for (i in 1:length(new_teams)){
  
  replaced_last_season$HomeTeam[replaced_last_season$HomeTeam == dropped_teams[i]] = new_teams[i]
  replaced_last_season$AwayTeam[replaced_last_season$AwayTeam == dropped_teams[i]] = new_teams[i]
  
}

replaced_last_season_teams = unique(replaced_last_season$HomeTeam)
```

# Modelling

## The first 50s

```{r}
first_preds = current_season[1:50, ]

first_preds$hda_expg1 = rep(NA, 50)
first_preds$hda_expg2 = rep(NA, 50)

first_preds$hdaou_expg1 = rep(NA, 50)
first_preds$hdaou_expg2 = rep(NA, 50)

new_train_set = replaced_last_season

## HDA
for (i in 1:5){
  
  #i = 1
  replaced_model = goalmodel(goals1 = round(new_train_set$hda_xhg), goals2 = round(new_train_set$hda_xag),
                             team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam,
                             model = 'gaussian')
  lower_bound = 1 + (i-1)*10
  upper_bound = i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred = predict_expg(replaced_model, return_df = T,
                      team1 = current_season$HomeTeam[lower_bound:upper_bound], 
                      team2 = current_season$AwayTeam[lower_bound:upper_bound])
  
  first_preds$hda_expg1[lower_bound:upper_bound] = pred$expg1
  first_preds$hda_expg2[lower_bound:upper_bound] = pred$expg2
  
  new_train_set = rbind(new_train_set, new_match_day) 
  
}

## HDA + OU
for (i in 1:5){
  
  #i = 1
  replaced_model = goalmodel(goals1 = round(new_train_set$hdaou_xhg), goals2 = round(new_train_set$hdaou_xag),
                             team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam,
                             model = 'gaussian')
  lower_bound = 1 + (i-1)*10
  upper_bound = i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred = predict_expg(replaced_model, return_df = T,
                      team1 = current_season$HomeTeam[lower_bound:upper_bound], 
                      team2 = current_season$AwayTeam[lower_bound:upper_bound])
  
  first_preds$hdaou_expg1[lower_bound:upper_bound] = pred$expg1
  first_preds$hdaou_expg2[lower_bound:upper_bound] = pred$expg2
  
  new_train_set = rbind(new_train_set, new_match_day) 
  
}
```

## The rest

```{r}
pred = current_season

pred$hda_expg1 = rep(NA, 380)
pred$hda_expg2 = rep(NA, 380)

pred$hdaou_expg1 = rep(NA, 380)
pred$hdaou_expg2 = rep(NA, 380)

played_matches = 50
new_train_set = current_season[1:played_matches, ]

## HDA
for (i in 1:33){
  
  model_xg = goalmodel(goals1 = round(new_train_set$hda_xhg), goals2 = round(new_train_set$hda_xag),
                       team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam, model = 'gaussian')
  
  lower_bound = played_matches + 1 + (i-1)*10
  upper_bound = played_matches + i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred_xg = predict_expg(model_xg, return_df = T,
                         team1 = new_match_day$HomeTeam, 
                         team2 = new_match_day$AwayTeam)
  
  pred$hda_expg1[lower_bound:upper_bound] = pred_xg$expg1
  pred$hda_expg2[lower_bound:upper_bound] = pred_xg$expg2
  
  new_train_set = rbind(new_train_set, new_match_day)
  
}

## HDA and OU
for (i in 1:33){
  
  model_xg = goalmodel(goals1 = new_train_set$hdaou_xhg, goals2 = new_train_set$hdaou_xag,
                        team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam, model = 'gaussian')
  
  lower_bound = played_matches + 1 + (i-1)*10
  upper_bound = played_matches + i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred_xg = predict_expg(model_xg, return_df = T,
                      team1 = new_match_day$HomeTeam, 
                      team2 = new_match_day$AwayTeam)
  
  pred$hdaou_expg1[lower_bound:upper_bound] = pred_xg$expg1
  pred$hdaou_expg2[lower_bound:upper_bound] = pred_xg$expg2
  
  new_train_set = rbind(new_train_set, new_match_day)
  
}
```

# Draft

```{r}
fbref_data = fb_match_results(country = '', gender = 'M', season_end_year = '2023',
                              non_dom_league_url = 'https://fbref.com/en/comps/9/history/Premier-League-Seasons')
names(fbref_data)[names(fbref_data) == 'Home'] = 'HomeTeam'
names(fbref_data)[names(fbref_data) == 'Away'] = 'AwayTeam'
fbref_data = fbref_data[, c('Date', 'HomeTeam', 'AwayTeam', 'HomeGoals', 'AwayGoals', 'Home_xG', 'Away_xG')]
row.names(fbref_data) = c(1:380)
fbref_data = fbref_data[order(as.Date(fbref_data$Date, format = "%d/%m/%Y")), ]
fbref_data
```
I have an idea (sort of) and a question for you.

Actually I'm not sure if the goalmodel is truely better than the ones in the paper because I've only tried one of the ideas.

About the parameters, this is my way: I got the parameters r and p from this formula: https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_parameterizations then generate samples using rnbinom(n, size, prob, mu) where size and prob are r and p respectively. And in my case with the five-big_league data set, home and away corner kicks have the same parameter p (prob) but different mu (mean) and r (size or dispersion). I'm not sure if I need to pay attention to this? I read that if two independent NB variables X∼NB(r,p) and Y∼NB(s,p) then X+Y∼NB(r+s,p), right? I attached an image of the paramaters, I think I got it correctly.

I don't understand the correlation on residuals. Do you mean we need a model, make predictions, get residuals then calculate the correlation? Why should I do it on the residuals instead of the data itself?

I noticed you have a folder for Bivariate Poisson but apparently you haven't finished. I've heard of the BivPois but I have never actually worked with it which I think I should.

Thank you for another paper. I had a quick look at it and I think it's to be honest. But I'll still try if I can derive something from it.

Thank you and Merry Christmas.





