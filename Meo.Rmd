# Libraries

```{r}
library(goalmodel)
```

# Data

```{r}
epl_19_20 = read.csv('https://www.football-data.co.uk/mmz4281/1920/E0.csv')
epl_20_21 = read.csv('https://www.football-data.co.uk/mmz4281/2021/E0.csv')
epl_21_22 = read.csv('https://www.football-data.co.uk/mmz4281/2122/E0.csv')
epl_22_23 = read.csv('https://www.football-data.co.uk/mmz4281/2223/E0.csv')

features = c('Date', 'HomeTeam', 'AwayTeam', 'FTHG', 'FTAG',
             'AvgCH', 'AvgCD', 'AvgCA', 'AvgC.2.5', 'AvgC.2.5.1')

epl_19_20 = epl_19_20[, features]
epl_20_21 = epl_20_21[, features]
epl_21_22 = epl_21_22[, features]
epl_22_23 = epl_22_23[, features]
```

# Some Functions

```{r}
ou_odds_to_prob = function(ou_odds, normalize=TRUE){
  
  stopifnot(all(ou_odds >= 1, na.rm=TRUE))
  
  if (!is.matrix(ou_odds)){
    
    if ('data.frame' %in% class(ou_odds)){
      ou_odds = as.matrix(ou_odds)
    } else {
      ou_odds = matrix(ou_odds, nrow=1,
                    dimnames = list(NULL, names(ou_odds)))
    }
  }
  
  # Prepare the list that will be returned.
  out = vector(mode='list', length=2)
  names(out) = c('probabilities', 'margin')
  
  # Some useful quantities
  n_odds = nrow(ou_odds)
  n_outcomes = ncol(ou_odds)
  
  # Inverted odds and margins
  inverted_odds = 1 / ou_odds
  inverted_odds_sum = rowSums(inverted_odds)
  out$margin = inverted_odds_sum - 1

  out$probabilities = inverted_odds / inverted_odds_sum
    
  ## do a final normalization to make sure the probabilities sum to 1 without rounding errors.
  if (normalize){
    out$probabilities = (1 * out$probabilities) / rowSums(out$probabilities)
  }
  
  return(out)
}
```

```{r}
odds_to_prob = function(odds, normalize=TRUE){
  
  stopifnot(all(odds >= 1, na.rm=TRUE))
  
  if (!is.matrix(odds)){
    
    if ('data.frame' %in% class(odds)){
      odds = as.matrix(odds)
    } else {
      odds = matrix(odds, nrow=1,
                    dimnames = list(NULL, names(odds)))
    }
  }
  
  # Prepare the list that will be returned.
  out = vector(mode='list', length=2)
  names(out) = c('probabilities', 'margin')
  
  # Some useful quantities
  n_odds = nrow(odds)
  n_outcomes = ncol(odds)
  
  # Inverted odds and margins
  inverted_odds = 1 / odds
  inverted_odds_sum = rowSums(inverted_odds)
  out$margin = inverted_odds_sum - 1

  out$probabilities = inverted_odds / inverted_odds_sum
    
  ## do a final normalization to make sure the probabilities sum to 1 without rounding errors.
  if (normalize){
    out$probabilities = (1 * out$probabilities) / rowSums(out$probabilities)
  }
  
  # Make sure the matrix of implied probabilities has column names.
  if (!is.null(colnames(odds))){
    colnames(out$probabilities) = colnames(odds)
  }
  
  # check if there are any probabilities outside the 0-1 range.
  problematic = apply(out$probabilities, MARGIN = 1, FUN=function(x){any(x > 1 | x < 0)})
  problematic[is.na(problematic)] = TRUE
  
  if (any(problematic, na.rm=TRUE)){
    warning(sprintf('Probabilities outside the 0-1 range produced at %d instances.\n',
                    sum(problematic)))
  }
  
  out$problematic = problematic
  
  return(out)
}
```

```{r}
mis_prob_sq_error = function(pars, trgt_probs){
  
  pars = exp(pars) # trick to avoid negative lambda parameters.
  hda_ou_probs = numeric(5)
  probmat = stats::dpois(0:49, lambda=pars[1]) %o% stats::dpois(0:49, lambda=pars[2])
  
  #1x2
  hda_ou_probs[2] = sum(diag(probmat))
  hda_ou_probs[1] = sum(probmat[lower.tri(probmat)])
  hda_ou_probs[3] = 1 - sum(hda_ou_probs[1:2])
  
  #ou
  total_goals = matrix(NA, nrow = 50, ncol = 50)
  
  for (i in 1:50){
    for (j in 1:50){
      total_goals[i, j] = (i-1) + (j-1)
    }
  }
  
  hda_ou_probs[4] = sum(probmat[total_goals > 2.5])
  hda_ou_probs[5] = sum(probmat[total_goals < 2.5])
  
  sum((hda_ou_probs - trgt_probs)^2)
  
}
```

```{r}
mis_prob_to_expg = function(probabilities){
  
  # Convert to matrix
  if (!is.matrix(probabilities)){
    if (is.numeric(probabilities)){
      probabilities = matrix(probabilities, nrow=1,
                              dimnames = list(NULL, names(probabilities)))
    } else {
      probabilities = as.matrix(probabilities)
    }
    
    
  }
  
  stopifnot(ncol(probabilities) == 5,
            all(abs(rowSums(probabilities) - 1 - 1) < 0.0001))
  
  expg = matrix(ncol=2, nrow=nrow(probabilities))
  sq_errors = numeric(nrow(probabilities))
  
  for (i in 1:nrow(probabilities)){
    
    optim_res = stats::optim(c(0,0), fn=mis_prob_sq_error,
                              trgt_prob=probabilities[i,])
    
    expg[i,] = exp(optim_res$par)
    sq_errors[i] = optim_res$value
    
  }
  
  out = list(expg = expg, sq_errors=sq_errors)
  
  return(out)
}
```

# Some preparations

```{r}
## last season
last_season = sub_21_22

## hda and ou
last_season_hda_prob = odds_to_prob(last_season[, c('AvgCH', 'AvgCD', 'AvgCA')])$probabilities
last_season_ou_prob = ou_odds_to_prob(last_season[, c('AvgC.2.5', 'AvgC.2.5.1')])$probabilities

last_season_hdaou_prob = cbind(last_season_hda_prob, last_season_ou_prob)
last_season_hdaou_expg = mis_prob_to_expg(last_season_hdaou_prob)

last_season$hdaou_xhg = last_season_hdaou_expg$expg[, 1]
last_season$hdaou_xag = last_season_hdaou_expg$expg[, 2]

## hda
last_season_hda_expg = prob_to_expg(last_season_hda_prob)

last_season$hda_xhg = last_season_hda_expg$expg[, 1]
last_season$hda_xag = last_season_hda_expg$expg[, 2]

## current season
current_season = sub_22_23

## hda and ou
current_season_hda_prob = odds_to_prob(current_season[, c('AvgCH', 'AvgCD', 'AvgCA')])$probabilities
current_season_ou_prob = ou_odds_to_prob(current_season[, c('AvgC.2.5', 'AvgC.2.5.1')])$probabilities

current_season_hdaou_prob = cbind(current_season_hda_prob, current_season_ou_prob)
current_season_hdaou_expg = mis_prob_to_expg(current_season_hdaou_prob)

current_season$hdaou_xhg = current_season_hdaou_expg$expg[, 1]
current_season$hdaou_xag = current_season_hdaou_expg$expg[, 2]

## hda
current_season_hda_expg = prob_to_expg(current_season_hda_prob)

current_season$hda_xhg = current_season_hda_expg$expg[, 1]
current_season$hda_xag = current_season_hda_expg$expg[, 2]
```

```{r}
current_season_teams = unique(current_season$HomeTeam)
last_season_teams = unique(last_season$HomeTeam)

new_teams = current_season_teams[!(current_season_teams %in% last_season_teams)]
dropped_teams = last_season_teams[!(last_season_teams %in% current_season_teams)] 
```

```{r}
replaced_last_season = last_season

for (i in 1:length(new_teams)){
  
  replaced_last_season$HomeTeam[replaced_last_season$HomeTeam == dropped_teams[i]] = new_teams[i]
  replaced_last_season$AwayTeam[replaced_last_season$AwayTeam == dropped_teams[i]] = new_teams[i]
  
}

replaced_last_season_teams = unique(replaced_last_season$HomeTeam)
```

# Modelling

## The first 50s

```{r}
first_preds = current_season[1:50, ]

first_preds$hda_expg1 = rep(NA, 50)
first_preds$hda_expg2 = rep(NA, 50)

first_preds$hdaou_expg1 = rep(NA, 50)
first_preds$hdaou_expg2 = rep(NA, 50)

new_train_set = replaced_last_season

## HDA
for (i in 1:5){
  
  #i = 1
  replaced_model = goalmodel(goals1 = round(new_train_set$hda_xhg), goals2 = round(new_train_set$hda_xag),
                             team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam,
                             model = 'gaussian')
  lower_bound = 1 + (i-1)*10
  upper_bound = i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred = predict_expg(replaced_model, return_df = T,
                      team1 = current_season$HomeTeam[lower_bound:upper_bound], 
                      team2 = current_season$AwayTeam[lower_bound:upper_bound])
  
  first_preds$hda_expg1[lower_bound:upper_bound] = pred$expg1
  first_preds$hda_expg2[lower_bound:upper_bound] = pred$expg2
  
  new_train_set = rbind(new_train_set, new_match_day) 
  
}

## HDA + OU
for (i in 1:5){
  
  #i = 1
  replaced_model = goalmodel(goals1 = round(new_train_set$hdaou_xhg), goals2 = round(new_train_set$hdaou_xag),
                             team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam,
                             model = 'gaussian')
  lower_bound = 1 + (i-1)*10
  upper_bound = i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred = predict_expg(replaced_model, return_df = T,
                      team1 = current_season$HomeTeam[lower_bound:upper_bound], 
                      team2 = current_season$AwayTeam[lower_bound:upper_bound])
  
  first_preds$hdaou_expg1[lower_bound:upper_bound] = pred$expg1
  first_preds$hdaou_expg2[lower_bound:upper_bound] = pred$expg2
  
  new_train_set = rbind(new_train_set, new_match_day) 
  
}
```

## The rest

```{r}
pred = current_season

pred$hda_expg1 = rep(NA, 380)
pred$hda_expg2 = rep(NA, 380)

pred$hdaou_expg1 = rep(NA, 380)
pred$hdaou_expg2 = rep(NA, 380)

played_matches = 50
new_train_set = current_season[1:played_matches, ]

## HDA
for (i in 1:33){
  
  model_xg = goalmodel(goals1 = round(new_train_set$hda_xhg), goals2 = round(new_train_set$hda_xag),
                       team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam, model = 'gaussian')
  
  lower_bound = played_matches + 1 + (i-1)*10
  upper_bound = played_matches + i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred_xg = predict_expg(model_xg, return_df = T,
                         team1 = new_match_day$HomeTeam, 
                         team2 = new_match_day$AwayTeam)
  
  pred$hda_expg1[lower_bound:upper_bound] = pred_xg$expg1
  pred$hda_expg2[lower_bound:upper_bound] = pred_xg$expg2
  
  new_train_set = rbind(new_train_set, new_match_day)
  
}

## HDA and OU
for (i in 1:33){
  
  model_xg = goalmodel(goals1 = new_train_set$hdaou_xhg, goals2 = new_train_set$hdaou_xag,
                        team1 = new_train_set$HomeTeam, team2 = new_train_set$AwayTeam, model = 'gaussian')
  
  lower_bound = played_matches + 1 + (i-1)*10
  upper_bound = played_matches + i*10
    
  new_match_day = current_season[lower_bound:upper_bound, ]
  
  pred_xg = predict_expg(model_xg, return_df = T,
                      team1 = new_match_day$HomeTeam, 
                      team2 = new_match_day$AwayTeam)
  
  pred$hdaou_expg1[lower_bound:upper_bound] = pred_xg$expg1
  pred$hdaou_expg2[lower_bound:upper_bound] = pred_xg$expg2
  
  new_train_set = rbind(new_train_set, new_match_day)
  
}
```

# Draft

```{r}
fbref_data = fb_match_results(country = '', gender = 'M', season_end_year = '2023',
                              non_dom_league_url = 'https://fbref.com/en/comps/9/history/Premier-League-Seasons')
names(fbref_data)[names(fbref_data) == 'Home'] = 'HomeTeam'
names(fbref_data)[names(fbref_data) == 'Away'] = 'AwayTeam'
fbref_data = fbref_data[, c('Date', 'HomeTeam', 'AwayTeam', 'HomeGoals', 'AwayGoals', 'Home_xG', 'Away_xG')]
row.names(fbref_data) = c(1:380)
fbref_data = fbref_data[order(as.Date(fbref_data$Date, format = "%d/%m/%Y")), ]
fbref_data
```
I have an idea (sort of) and a question for you.

1/ Using both 1X2 and OU odds to convert to expected goals

Instead of only using HDA odds (1X2) to convert to expected goals, I use both 1X2 and OU (over/under) odds to calculate the expected goals. To save your time, I attached some R codes so that you can just run and see the results. Let me know how you think about it. Below is the summary of the code:

1a/ In the Some Functions section

I just wrote one more function which converts OU odds to OU probabilities then use your way to calculate it (to minimise the sum squared error), except that I deleted some codes for simplification.
I still got an error from the score_predictions() function although I remember that you fixed it and it worked last time. I again turned the any(observed <= ncat) condition off.

1b/ In the Some preparations section

Since the model can't predict the very first matches in a season because there are 3 new teams that didn't play on the last season, my idea is just simply replace the names of the 3 dropped teams by the names of the 3 new teams so that we can predict all matches in a season.

1c/ In the Modelling section

I only use the last season data to predict the first 50 matches in the new season, then stop using the last season data from match 51st onwards. You will see I make 10 predictions at once since usually we have 10 matches in a matchday (I break down the performance into 2 parts, one is from match 1 to 380 and the second one is from match 51 to 380). Also, apart from using log/brier/rps score as our metrics, I tried mean absolute error of the home goal, away goal as well as GE (total goals) and SUP (goal diffference) as metrics. Looking at the probabilistic metrics, you will see that there are more green in the HDA + OU area.

* There are many different comparisons we can make but here I just want to compare HDA versus HDA + OU.
* The GE error can be reduced pretty obviously if we use OU only.
* I have only tested on Engling Premier League.

https://docs.google.com/spreadsheets/d/1i9v0kZOHZYSPJ0iKAJm-kI8J0WaFblLYKmvTVJeKkus/edit?usp=sharing

2/ How does the weights computed from the weight_dc() function actually work in Gaussian model?

I read your articles about it here but I haven't understood to be honest. Could you explain to me in another simpler way or suggest me other sources that I should read or watch?

https://opisthokonta.net/?p=890 1
https://opisthokonta.net/?p=913 2
https://opisthokonta.net/?p=927 3
https://opisthokonta.net/?p=939 4
https://opisthokonta.net/?p=1013 (weight)

From the file goalmodel_fit.R, line 419, you place the DC weights to the weights argument. It's like weighted least squares for me, is it related? 

3/ Since treating expected goals calculated from bookies' odds as the response variables gives me better results than others (full time goals or expected goals from opta), I tried round it to integer so that I can together use it with DC and CMP model but I got this error message for DC:

"Warning: predict_goals: negative proabilities in game 'x' " (x is from 1 to 10)
And this error for CMP:
"Error in stats::optim(par = parameter_vector, fn = negloglik, goals1 = goals1, :non-finite finite-difference value [41]"

Do you know why?

Thank you.

4/ Why to compute the log-link functions?
5/ Why doesn't rounding work?


I tried using two-step estimation with parameters estimated from the gaussian model and here are the results (sheet 2):
https://docs.google.com/spreadsheets/d/1i9v0kZOHZYSPJ0iKAJm-kI8J0WaFblLYKmvTVJeKkus/edit#gid=672356215
You have any idea why I got the exact parameters? It makes me feel like the DC didn't do anything but to copy the parameters from the Gaussian model.

As for the "negative probabilites in game x" warning, I'm still trying to figure it out.

About the error from score_prediction(), I realised that I was using the older version. I'll need to reinstall it.

By the way, do you know any good sources (blogs/books/etc) on betting? Once I have the model, I'd like to test out how much I would win or lose?

Thank you.
By the way,
